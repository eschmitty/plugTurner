/*
  Plug Motor
  2022 - eschmitt
*/

#include <AccelStepper.h>
#include <Encoder.h>
#include <U8g2lib.h>
#include <Wire.h> //Library for I2C interface
#include <TM1637Display.h>

#define HWSERIAL Serial1
#define modeSw 2
#define zeroLed 16
#define spindleLockLed 17
#define stepPin 14
#define dirPin 15
#define zeroSw 10
#define motorEn 8
//#define rpmLed 21
//#define holdLed 5

long potVal = 0;
int step1Speed = 0;
int speedMin = 0;
float speedMax = 266.666666;
int jogSpeed = 3200;
int spinPos = 0;
float rpm = 0;
float spinPos2 = 0;
char spinPosStr[4];
char spinPosPr[4];
char rpmStr[3];
int oldRpm = 0;
bool oldMode = false;
static unsigned char bass[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x01,
  0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x14, 0x06, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x00, 0xb0, 0x03, 0x00,
  0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x60,
  0x00, 0x0c, 0x0c, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x01, 0x80, 0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x02, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x36, 0x80, 0x01,
  0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xfe, 0xf1, 0xff, 0xff, 0x00,
  0x06, 0x01, 0x02, 0x06, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0xf0, 0x0e,
  0x7e, 0xe0, 0xf1, 0x1f, 0x88, 0x82, 0x49, 0x08, 0x00, 0x80, 0x00, 0x01,
  0x00, 0xc0, 0xdf, 0xff, 0x1d, 0x00, 0x78, 0xf8, 0xf7, 0xa3, 0x05, 0x04,
  0x00, 0x40, 0x00, 0x01, 0x00, 0xf8, 0x77, 0xf4, 0x1f, 0xf0, 0x03, 0x8f,
  0xfc, 0x0f, 0x12, 0x0c, 0x00, 0x20, 0x01, 0x01, 0x00, 0x7e, 0xfe, 0xc0,
  0xf0, 0x00, 0xf0, 0xc0, 0x81, 0xff, 0x13, 0x1e, 0x00, 0x20, 0x00, 0x01,
  0x00, 0x1e, 0xec, 0x80, 0x20, 0xe1, 0x00, 0x1e, 0x78, 0xc0, 0xdf, 0x03,
  0x00, 0x18, 0x00, 0x01, 0x00, 0x14, 0x60, 0x80, 0x40, 0x01, 0x38, 0x80,
  0x03, 0x1f, 0xfc, 0x01, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x28, 0x18, 0x80,
  0x00, 0x01, 0x80, 0x1e, 0x78, 0xc0, 0xa1, 0x07, 0x00, 0x1d, 0x00, 0x01,
  0x00, 0x48, 0x20, 0x00, 0x00, 0x1f, 0x00, 0xe0, 0x81, 0x1f, 0x78, 0xc8,
  0xff, 0x04, 0x00, 0x01, 0x00, 0xc0, 0x0a, 0x00, 0x00, 0xe1, 0x00, 0x00,
  0x1c, 0xc0, 0x07, 0xfc, 0xff, 0x07, 0x00, 0x01, 0xc0, 0x9f, 0x00, 0x00,
  0x00, 0x01, 0x5f, 0x00, 0x80, 0x01, 0xe0, 0x17, 0x00, 0x00, 0x00, 0x01,
  0x60, 0x10, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x03, 0x00, 0xf8, 0x00, 0x00,
  0xfc, 0x0d, 0x00, 0x01, 0x80, 0x31, 0x00, 0x00, 0x00, 0x21, 0x00, 0xfc,
  0x07, 0x00, 0xf0, 0xc7, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x04, 0x00,
  0x80, 0x00, 0x20, 0x00, 0xfc, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x02, 0x04, 0x00, 0x80, 0x00, 0x00, 0x08, 0x00, 0x00, 0xff, 0x07,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xf8, 0xff, 0x01, 0x00, 0x01, 0x00, 0x3c, 0x10, 0x00,
  0x40, 0xfe, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x30, 0x10, 0x00, 0x40, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x10, 0x00, 0x60, 0x10, 0x00, 0xff,
  0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xc0, 0x21, 0x00,
  0x30, 0x10, 0x00, 0x00, 0x00, 0xfe, 0x01, 0x00, 0x80, 0x1f, 0x00, 0x02,
  0x00, 0x00, 0x4f, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xf8, 0x20, 0x00, 0x02, 0x00, 0x00, 0xdc, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x3f, 0x40, 0x00, 0x02, 0x00, 0x00, 0xf0, 0xff,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0b, 0x80, 0x01, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
  0x06, 0x00, 0x23, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf0, 0x10, 0x00, 0x00, 0x38, 0x04,
  0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x80, 0xdf, 0x1f, 0x19,
  0x00, 0x00, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00,
  0xe0, 0x83, 0x80, 0x08, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xd0, 0x0f, 0x00, 0xf8, 0x00, 0x03, 0x08, 0x00, 0x00, 0x00, 0x06,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xfc, 0xff, 0x0f, 0x00, 0x84, 0x08,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xf4, 0xff,
  0x01, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x10, 0x04, 0x00, 0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 0x10, 0x04,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00,
  0x00, 0x00, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

AccelStepper step1(AccelStepper::DRIVER, stepPin, dirPin); // type, step, dir
Encoder enc1(23, 22);
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ 11,/* clock=*/ 19,/* data=*/ 18);   // Reset pin is required for this display

void setup() {
  //HWSERIAL.begin(9600);
  delay(5000);3 3
  Wire.begin();
  u8g2.setI2CAddress(0x78);  //if DC is pulled low- 10k resistor between DC and GND
  u8g2.begin();
  u8g2.clearBuffer();  // Clear display buffer
  u8g2.drawXBM(0, 0, 128, 64, bass);
  u8g2.sendBuffer(); // Send display buffer contents to OLED buffer.
  delay(1000);
  step1.setCurrentPosition(160000);
  step1.setMaxSpeed(speedMax);
  step1.setSpeed(0);
  pinMode(zeroLed, OUTPUT);
  pinMode(motorEn, INPUT);
  pinMode(spindleLockLed, OUTPUT);
  pinMode(modeSw, INPUT_PULLUP);
  pinMode(zeroSw, INPUT_PULLUP);
  delay(5); //allow time for pullup voltage to rise
  digitalWrite(stepPin, LOW);
  digitalWrite(dirPin, LOW);
  setZero();
  enc1.write(40000);
  oldMode = !digitalRead(modeSw); //This forces "mode setup" to run on the first loop
}

void loop() {
  modeChange();
  motorLock();
  digitalWrite(spindleLockLed, HIGH);
  switch (digitalRead(modeSw)) {
    case HIGH:
      step1Speed = (enc1.read() % 400) * (speedMax / 400);
      step1.setSpeed(step1Speed);
      if (step1Speed != oldRpm)  {
        oldRpm = step1Speed;
        rpm = step1Speed / 26.666666 + .05;
        dtostrf(rpm, 1 , 1, rpmStr);
        u8g2.clearBuffer();  // Clear display buffer
        u8g2.setFont(u8g2_font_logisoso38_tf);
        u8g2.drawStr(58 - (u8g2.getStrWidth(rpmStr) / 2), 52, rpmStr);
        u8g2.setFont(u8g2_font_logisoso20_tf);
        //u8g2.drawStr(64 - (u8g2.getStrWidth("RPM") / 2), 64, "RPM");
        u8g2.drawStr(127 - (u8g2.getStrWidth("R")), 20, "R");
        u8g2.drawStr(127 - (u8g2.getStrWidth("P")), 42, "P");
        u8g2.drawStr(127 - (u8g2.getStrWidth("M")), 64, "M");
        u8g2.sendBuffer(); // Send display buffer contents to OLED buffer.
      }
      step1.runSpeed();
      break;
    case LOW:
      if (enc1.read() != (step1.currentPosition() / 4)) {
        step1.moveTo(enc1.read() * 4); // 100 clicks per rev of encoder, 4 pulses per click
      }
      if (step1.distanceToGo() == 0) {
        spinPos = ((round(abs(step1.currentPosition()) * .225) + .5));
        spinPos2 = spinPos % 360;
        if (spinPos2 == 360) {
          spinPos2 = 0;
        }
        dtostrf(spinPos2, 0, 0, spinPosStr);
        sprintf(spinPosPr, "%s", spinPosStr);
        u8g2.clearBuffer();
        u8g2.setFont(u8g2_font_courB10_tr);
        u8g2.drawStr(64 - (u8g2.getStrWidth("Spindle") / 2), 9, "Spindle");
        u8g2.drawStr(64 - (u8g2.getStrWidth("Position") / 2), 20, "Position");
        u8g2.drawHLine(0, 22, 128);
        u8g2.setFont(u8g2_font_logisoso38_tf);
        u8g2.drawStr(64 - (u8g2.getStrWidth(spinPosPr) / 2), 63, spinPosPr);
        u8g2.drawGlyph((64 - (u8g2.getStrWidth(spinPosPr) / 2)) + u8g2.getStrWidth(spinPosPr) - 2, 68, 0x00b0);
        //        u8g2.drawCircle(110, 32, 15, U8G2_DRAW_ALL);
        //        if (spinPos2 == 90) {
        //          u8g2.drawHLine(110, 32, 15);
        //        }
        //        else if (spinPos2 == 180) {
        //          u8g2.drawVLine(110, 32, 15);
        //        }
        //        else if (spinPos2 == 270) {
        //          u8g2.drawHLine(95, 32, 15);
        //        }
        //        else if (spinPos2 == 0) {
        //          u8g2.drawVLine(110, 17, 15);
        //        }
        u8g2.sendBuffer();
      }
      step1.run();
      break;
  }
}

void setZero() {
  u8g2.clearBuffer();  // Clear display buffer
  u8g2.setFont(u8g2_font_freedoomr10_tu);
  u8g2.drawRFrame(22, 3, 85, 16, 7);
  u8g2.drawStr(64 - (u8g2.getStrWidth("SET ZERO") / 2), 18, "SET ZERO");
  u8g2.drawStr(64 - (u8g2.getStrWidth("SET DIAL TO") / 2), 34, "SET DIAL TO");
  u8g2.drawStr(64 - (u8g2.getStrWidth("0 AND PRESS") / 2), 48, "0 AND PRESS");
  u8g2.drawStr(64 - (u8g2.getStrWidth("CAL BUTTON") / 2), 62, "CAL BUTTON");
  u8g2.sendBuffer(); // Send display buffer contents to OLED buffer.
  while ((digitalRead(zeroSw) == HIGH)) { //wait for button press
    pulse(zeroLed);
  }
  delay(5); //debounce
  analogWrite(zeroLed, 0);
}

void modeChange() {
  if (digitalRead(modeSw) != oldMode) { //Mode setup. code in this 'if' statement only runs when the mode switch positions changes.
    switch (digitalRead(modeSw)) {
      case HIGH: //RPM Mode
        oldMode = HIGH;
        oldRpm = -1;
        break;
      case LOW: // Jog Mode
        oldMode = LOW;
        step1.setCurrentPosition(((enc1.read() % 400) * 4) + 160000); //these two lines ensure the position reading
        enc1.write((enc1.read() % 400) + 40000);                      //matches the dial after step count increases in RPM mode
        step1.setMaxSpeed(jogSpeed);
        step1.setAcceleration(1600);
        break;
    }
  }
}

void pulse(int x) {
  float in, out;

  for (in = 0; in < 6.283; in = in + 0.00157)
  {
    out = sin(in) * 127.5 + 127.5;
    analogWrite(x, out);
  }
}

void motorLock() {
  while (digitalRead(motorEn) == HIGH) {
    //   switch (digitalRead(modeSw)) {
    //     case HIGH:
    oldRpm = oldRpm + 1; //forces display update on spindle lock exit
    //      break;
    //  case LOW:
    step1.setCurrentPosition(enc1.read() * 4); //allows repositioning of the encoder while spindle lock is off
    //  break;
    // }
    u8g2.clearBuffer();  // Clear display buffer
    u8g2.setFont(u8g2_font_courB12_tf);
    u8g2.drawStr(64 - (u8g2.getStrWidth("Spindle Free") / 2), 14, "Spindle Free");
    u8g2.drawStr(64 - (u8g2.getStrWidth("Press motor") / 2), 28, "Press motor");
    u8g2.drawStr(64 - (u8g2.getStrWidth("lock button") / 2), 42, "lock button");
    u8g2.drawStr(64 - (u8g2.getStrWidth("to resume.") / 2), 56, "to resume.");
    u8g2.sendBuffer(); // Send display buffer contents to OLED buffer.
    pulse(spindleLockLed);
  }
}
